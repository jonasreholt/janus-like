% Use Roberts article to argue reversability and that local inversion is enough
% Also prove bijection (reversibility) of for-loops
\section{Janus-like language definition \rr} \label{sec:language-def}
This project alters and extents the syntax for \texttt{Janus} to make it better match modern
programming languages, and to simplify certain properties of the language.
This "new" language will be an imperative reversible language like
\texttt{Janus}, and henceforth will be noted as \lan
(short for Janus alike programming alternative) in this report.
But before altering the syntax and functionality of \texttt{Janus}, a more formal characterizations
of reversibility must be made.

Reversible computation refers to the use of logically reversible transformations \cite{ARTICLE:2},
and require two things: Local reversibility and global reversibility.

\begin{myDefinition}{Local reversibility}{def:localReversibility}
For a local process to be reversible information from step to step must be preserved, meaning no
information is destroyed \cite{ARTICLE:1}.
\end{myDefinition}

\begin{myDefinition}{Global reversibility}{def:globalReversibility}
A global process can only be reversible if the mapping from a start state to a final state is
bijective \cite{ARTICLE:1}. 
\end{myDefinition}
\noindent
This means that every construct of \lan must preserve information over time, so the program
knows where to start of when running in either direction, and that there must be a "one-to-one"
transformation from every state. e.g. consider the assignment operator \texttt{var = 10}. This
statement has no way of undoing itself, as we do not know what \texttt{var} was before this
assignment, meaning it goes against definition \ref{def:def:localReversibility}. It also removes
the bijective property of the program, as all previous states of \texttt{var} leads to the same
final state where \texttt{var == 10}.
\\
\\
The definition for logical reversibility stated above does allow for all programs to be reversible,
as one could simply save a copy of the initial state and final state, as this would make
the program bijective, as the final program becomes a tuple $(state_{initial}, state_{final})$,
making the program transformation $\{state_{initial}\} \to \{state_{initial}, state_{final}\}$.
These programs will however not live up to Landauer's Principle \cite{article:3}, as every
individual step is not reversible. It is therefore imminent that all construct of \lan are
reversible in them self.

\subsection{Scoping rules \rr}
\lan is statically scoped with the exception of the global store. Because the global store is
declared within the main function, this cannot be statically scoped, as they would no be globally
available then. The implication of all variables being statically scoped, means that it is only
global variables that can cross implicitly between procedures; this is a consequence of only
having the global variables declared in main, and then local variables allowed declared within a
procedure.

\subsection{Data types \rr}
\lan supports the data types integers, booleans, and arrays of integers or booleans.
The constraint coming from reversibility on data types, is that simple types such as floats,
cannot be accurately implemented, as the type in itself is imprecise, meaning no perfect inverse
is ensured to exist.
\\
\\
There only build in function is \texttt{size(id)}, which will give the length of array $id$.

\subsection{Declaration of variables \rr}
There are essentially two types of variables: Global and local. Because a global variable is
always in scope, it preserves the information at all time (assuming all operations done on it
are reversible). Hence global variable declaration can simply be done by:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{<id>} & $\underleftrightarrow{\text{Inverse of}}$ & no inverse \\
        \texttt{<id>[]}
    \end{tabular}
\end{table*}
\noindent
Local variables are more tricky, as they will leave the scope, meaning we cannot know the value
of the variable when running the program backwards, if the variable have left scope. Hence there
needs to be some operation stating what the value of the variable is when it is last used, so
the program step of leaving the scope of a local variable also becomes reversible. This can be
done in the following way:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{local <type> <id>}
        & $\underleftrightarrow{\text{Inverse of}}$ &
        \texttt{dealloc <type> <id> == <expr}
    \end{tabular}
\end{table*}
\noindent
It is important to note, that declaring a local, does not open a scope, meaning when a variable
$y$ is shadowed by a local $x$, it is not brought into the light by deallocation of $x$.
This is a design choice taken, as it eases the translation to \texttt{C++}.

\subsection{Modification arithmetics \rr}
To modify a variable there needs to be an inverse function of the operator, such that the
modification can be reversed. As the only datatypes for \lan are integers and booleans,
the only operators with an inverse (the function is bijective) is addition, subtraction, and
exclusive or. Multiplication and division cannot be used, as they are not each others inverse
when operating on natural numbers. Hence the operation becomes:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{<id> += <expr1>} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{<id> -= <expr1} \\
        \texttt{<id> \textasciicircum= <expr2>} & & \texttt{<id> \textasciicircum= <expr2>}
    \end{tabular}
\end{table*}
\noindent
Where \textasciicircum ~indicates exclusive or.

\subsection{Arithmetics \rr}
Performing arithmetics on expressions of the language does not require, that the arithmetic function
is bijective, as it is only the state transformations that need be bijective, e.g. in
\texttt{a += 5 $\*$ 6}, the expression \texttt{5 $\*$ 6} is not the "altering" function, and
inverse of the whole statement would simply be subtracting \texttt{5 $\*$ 6} from \texttt{a}.
\\
\\
The only thing one needs to remember is, that a variable name cannot occur at both side if the
statement is to be reversible. Having this constraint ensures forward and backward determinism
of the modifications, which will be proven in section \nameref{subsec:reversibility}.

\subsection{If statements \rr}
The \texttt{if}-statements are similar to those of \texttt{Janus}:

\begin{table*}[h!]
    \centering
    \begin{tabular}{lcl}
        \texttt{if (<expr1>) \{} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{if (<expr2>) \{} \\
        \texttt{ <stmts1>} && \text{<stmts1>$^{-1}$} \\
        \texttt{\} fi <expr2>} && \texttt{\} fi <expr1>} \\
        \texttt{else \{} && \texttt{else \{} \\
        \texttt{ <stmts2>} && \text{ <stmts2>$^{-1}$} \\
        \texttt{\}} && \texttt{\}}
    \end{tabular}
\end{table*}
\noindent
Where the \texttt{else} part can be omitted.

\subsection{Loops \rr}
\lan only supports \texttt{for}-loops. These loops are closer to that of \texttt{C++} syntax, and
it allows for some easy optimizations compared to \texttt{Janus}' \texttt{from}-loop construction,
which are presented in \cite{janus};
the initial condition and the end condition will always be true, so the only added assertion in
the construct is, that the initial condition must not be true after each iteration.

The loop construct syntax can be seen in table \ref{table:for-loop-inverse}.
\begin{table}[!h]
    \centering
    \begin{tabular}{l}
        \texttt{for local <type> <id> = <expr1> [, invariant (<expr2>)] \{} \\
        \texttt{ <stmts>} \\
        \texttt{\} <incr>; until (dealloc <type> <id> == <expr3>)} \\ \\
        $~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\underleftrightarrow{\text{Inverse of}}$ \\ \\
        \texttt{for local <type> <id> = <expr3> [, invariant (<expr2>)], <inc>$^{-1}$ \{ }\\
        \texttt{ <stmts>$^{-1}$} \\
        \texttt{\} until (dealloc <type> <id> == <expr1>)} 
    \end{tabular}
    \caption{\texttt{for}-loop construct in \lan and its inverse.}
    \label{table:for-loop-inverse}
\end{table}
\noindent
Where \texttt{inc} is a modification operation typically on <id>, $a^{-1}$ indicates that
$a$ is reversed, \texttt{[invariant (<expr>)]} is an optional loop invariant, and having
\texttt{<inc>} above the body executes it before the body and if it is after the body, it
is executed after.
\\
\\
Moving the \texttt{<inc>} operation when reversing the loop is a necessity to make sure that
\texttt{<id>} always have to correct value when going into an iteration. If the operation was not
moved, the loop would be unaligned with its reversion. E.g. if the loop iterated over a list,
it might stop when \texttt{<id>} is equal to the length of the list. If we reversed without moving
the \texttt{<inc>} operation, the first iteration of the loop would access the index of the list
length, which would be out of bounds.
\\
\\
The optional loop invariant works both as a way to transfer information to the optimizer, and
as run-time checks, if it cannot be optimized. It is checked at initialization of the loop, at the
start of each iteration (maintenance), and at termination. Further information on this can be found
in section \nameref{sec:z3}.

\subsection{Procedures \rr}
Procedures in \lan does not have a return value; every outcome is exposed through side
effect, by letting arguments be passed by reference. Return values are omitted because it
complicates preserving reversibility, as the program needs a way to know where to enter and exit
the procedure. This can be done by labeling all exits and possible enter areas with a condition,
so it would require the programmer to know the exact state of the program at all possible exit areas.
Procedures have therefore been kept free of return values for simplicity. Procedures in \lan are
non-recursive. This decision was taken for simplicity during the optimization phase.
\\
\\
In regard to arguments, they can either be a constant value or a previous declared variable. This
extinction needs to be taken, to ensure reversibility, as a procedure has no way of knowing, whether
a given argument is a constant or variable, unless stated in the procedure definition. If a variable
was passed by value without being constant, it would be the same as creating a local variable at
the start of the procedure; and given that the procedure input can change for every call, keeping
track of the deallocation condition becomes complex. Variables are therefore forced to be either
pass by reference or a constant. Hence defining a procedure can be done as:

\begin{lstlisting}
    procedure <id>(<args>) {
        <stmts>
    }
\end{lstlisting}
\noindent
Where \texttt{<args>} is a comma separated list of arguments written \texttt{<type> <id>},
\texttt{<type> <id>[<constant>]} or
\texttt{<type> const <id>}, where \texttt{const} indicates that the given argument is passed by
value, and the value cannot be altered in the procedure.
\\
\\
The reversibility of a procedure is straightforward now that all underlying statements are
reversible. It is simply done by:

\begin{table*}[!h]
    \centering
    \begin{tabular}{lcl}
        \texttt{call <id>(<args>)} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{uncall <id>(<args>)}
    \end{tabular}
\end{table*}
\noindent
Where \texttt{uncall} simply reverse the underlying statements.

\subsection*{Example program \rr}
Given a number $n$ the program seen in listing \ref{lst:fib} produces the n'th fibonacci
pair. The global store, which works as the starting state of the program, is defined within
\lsin{main}; this include the starting fibonacci pair
\lsin{x1} and \lsin{x2}. Hence the program actually ends with \lsin{x1} equal to the $n$'th
and \lsin{x2} equal to the $(n+1)$'th fibonacci number.

All \lan procedure are reversible in them self, except for the main function. Running the program
forward is invoking it as it is. To reverse the program, \lsin{main} must be altered, so
\lsin{x1} and \lsin{x2} are the $n$'th and $(n+1)$'th fibonacci numbers, and
\lsin{call fib(x1, x2, 10)} is changed to \lsin{uncall fib(x1, x2, 10)}.

\begin{lstlisting}[language=C++, label={lst:fib}, caption={Program finding the \lsin{n}'th fibonacci number.}]
procedure fib(int x1, int x2, const int n) {
    for local int i = 1 {
        local int tmp = x2 - x1
        x2 += x1
        x1 += tmp
        dealloc int tmp = x1 - (x2 - x1)
    } i += 1, until (dealloc int i = n)
}

procedure main() {
    int x1 = 0
    int x2 = 1
    
    call fib(x1, x2, 10)
}
\end{lstlisting}


\subsection{Formal definition of syntax \rr}
The language \lan can be formally written in Backus-Naur form as:

\begin{verbatim}
    <program> := <p-decls>
    <p-decls> := <p-decl> <p-decls> | ""

    <p-decl>  := "procedure" <id> "(" <f-args> ")" "{" <stmts> "}"

    <f-args>  := <f-args'> | ""
    <f-args'> := <f-arg> "," <f-args'>
               | <f-arg>

    <f-arg>   := <type> <id>
               | <type> <id> "[" <const> "]"
               | "const" <type> <id>

    <a-args>  := <a-args'> | ""
    <a-args'> := <a-arg> "," <a-args'>
               | <a-arg>
    
    <a-arg>   := <id>
               | <id> "[" <expr> "]"
               | <constant>

    <type>    := "int" | "bool"

    <stmts>   := <stmt> <stmts> | ""
    <stmt>    := "local" <type> <id> "=" <expr>
              | "dealloc" <type> <id> "=" <expr>
              | <id> <mod-op> "=" <expr>
              | <id> "[" <expr> "]" <mod-op> "=" <expr>
              | <id> "<=>" <id>
              | "if" "(" <expr> ")" "{" <stmts> "}" "fi" "(" <expr> ")" "else" "{" <stmts> "}"
              | "if" "(" <expr> ")" "{" <stmts> "}" "fi"
              | "for" "local" <type> <id> "=" <expr> <inv>
                "{" <stmts> "}"
                <id> <mod-op> "=" <expr> "," "until" "(" "dealloc" <type> <id> "=" <expr> ")"
              | "for" "local" <type> <id> "=" <expr> <inv> "," <id> <mod-op> "=" <expr>
                "{" <stmts> "}"
                "until" "(" "dealloc" <type> <id> "=" <expr> ")"
              | "call" <id> "(" <a-args> ")"
              | "uncall" <id> "(" <a-args> ")"
              | "assert" "(" <expr> ")"

    <inv>    := "," "invariant" "(" <expr> ")" | ""

    <expr>    := <constant> | <id> | <id> "[" <expr> "]" | <expr> <bin-op> <expr>
              | "size" "(" <id> ")" | "not" "(" <expr> ")"

    <bin-op>  := "+" | "-" | "^" | "*" | "/" | "%" | "&" | "&&" | "|" | "||" | ">"
              | ">=" | "<" | "<=" | "!=" | "=="
    
    <mod-op>  := "+" | "-" | "^"
\end{verbatim}

\subsection{Semantics \rr}
The operational semantics of \lan programs are similar to those presented for \texttt{Janus}
in \cite{janus}. It differentiate in regards to asserts, loops, function calls/uncalls
as these can carry parameters in \lan, and the introduction of local
variables. It is therefore, only these operational semantics, that will be presented in this
report. For completeness the semantics from \cite{janus} that is also viable for \lan are
included in the below rules. The include \texttt{AssVar} \eqref{eq:AssVar}, \texttt{AssArr}
\eqref{eq:AssArr}, \texttt{IfTrue} \eqref{eq:IfTrue}, \texttt{IfFalse} \eqref{eq:IfFalse},
and \texttt{Seq} \eqref{eq:Seq}.
\\
\\
The operational semantic for a \lan assert can be seen in equation \eqref{eq:assert},
local declaration and deallocation equation \eqref{eq:local} and \eqref{eq:dealloc},
procedure calls/uncalls can be seen in \eqref{eq:Call} and \eqref{eq:Uncall},
for-loop can be seen in equation \eqref{eq:loop1Main} to
\eqref{eq:loop2BaseInv}. Syntax follows the one introduced in \cite{pld}, so
environments, $\sigma$, represents stores binding left-values
to values. Adding a mapping of variable $id$ to value $y$ to a store is represented as
$\sigma[id \mapsto y]$, and applying a store to a left-value results to the stored value,
and is written as $\sigma(id)$. Every given statement takes a store and returns the possible
modified store. The procedure store $\Gamma$ is a partial function from the joint set
of identifiers and their arguments, to sequence of statements.

\begin{multicols}{2}
    \begin{equation} \label{eq:AssVar}
        \frac{\sigma \vdash_{expr} e \leadsto v}
        {\sigma \vdash_{stmt} id~ \assigneq e \leadsto
            \sigma[id \mapsto \llbracket \oplus \rrbracket(\sigma(id), v)]}
        \text{\texttt{AssVar}}
    \end{equation}
    \break
    \begin{equation} \label{eq:AssArr}
        \frac{\sigma \vdash_{expr} e_1 \leadsto v_1 ~~
            \sigma \vdash_{expr} e_2 \leadsto v_2}
        {\sigma \vdash_{stmt} id[e_1] \assigneq e_2 \leadsto
            \sigma[id[e_1] \mapsto \llbracket\oplus\rrbracket(\sigma(id), v_2)]}
        \text{\texttt{AssArr}}
    \end{equation}
\end{multicols}

\begin{equation} \label{eq:IfTrue}
    \frac{\sigma \vdash_{expr} e_1 \leadsto true ~~
        \sigma \vdash_{stmt} s_1 \leadsto \sigma' ~~
        \sigma \vdash_{expr} e_2 \leadsto true}
    {\sigma \vdash_{stmt} if~e_1~then~\{s_1\}~fi(e_2)~else~\{s_2\} \leadsto \sigma'}
    \text{\texttt{IfTrue}}
\end{equation}

\begin{equation} \label{eq:IfFalse}
    \frac{\sigma \vdash_{expr} e_1 \leadsto false ~~
        \sigma \vdash_{stmt} s_2 \leadsto \sigma' ~~
        \sigma \vdash_[expr] e_2 \leadsto false}
    {\sigma \vdash_{stmt} if~e_1~then~\{s_1\}~fi(e_2)~else~\{s_2\} \leadsto \sigma'}
    \text{\texttt{IfFalse}}
\end{equation}

\begin{multicols}{2}
    \begin{equation} \label{eq:Call}
        \frac{\sigma \vdash_{stmt} \Gamma(id, args) \leadsto \sigma'}
        {\sigma \vdash_{stmt} call~id(args) \leadsto \sigma'}
        \text{\texttt{Call}}
    \end{equation}
    \break
    \begin{equation} \label{eq:Uncall}
        \frac{\sigma' \vdash_{stmt} \Gamma(id, args) \leadsto \sigma}
        {\sigma \vdash_{stmt} uncall~id(args) \leadsto \sigma'}
        \text{\texttt{Uncall}}
    \end{equation}
\end{multicols}

\begin{multicols}{2}
    \begin{equation} \label{eq:Seq}
        \frac{\sigma \vdash_{stmt} s_1 \leadsto \sigma' ~~
            \sigma' \vdash_{stmt} s_2 \leadsto \sigma''}
        {\sigma \vdash_{stmt} s_1~s_2 \leadsto \sigma''}
        \text{\texttt{Seq}}
    \end{equation}
    \break
    \begin{equation} \label{eq:assert}
        \frac{\sigma \vdash_{expr} e \leadsto true}
        {\sigma \vdash_{assert} \text{assert}(e) \leadsto \sigma}
        \text{\texttt{Assert}}
    \end{equation}
\end{multicols}

\begin{multicols}{2}
    \begin{equation} \label{eq:local}
        \frac{\sigma \vdash_{expr} e \leadsto v}
        {\sigma \vdash_{Local} \text{local } t \text{ id } = e \leadsto \sigma[id \mapsto v]}
        \text{\texttt{Local}}
    \end{equation}
    \break
    \begin{equation} \label{eq:dealloc}
        \frac{\sigma \vdash_{expr} e \leadsto v ~~
            v == \sigma(id)}
        {\sigma \vdash_{dealloc} \text{dealloc } t \text{ id } = e \leadsto \sigma\backslash \{id\}}
        \text{\texttt{Dealloc}}
    \end{equation}
\end{multicols}

\begin{equation} \label{eq:loop1Main}
    \frac{\sigma \vdash_{local} \text{local } t \text{ id } = e_1 \leadsto \sigma' ~~
        \sigma' \vdash_{loop1} (e_1, s, e_2, e_3) \leadsto \sigma''}
    {\sigma \vdash_{stmt} \text{for local }t\text{ id }= e_1 ~\{s\}\text{ id }\assigneq e_2, \text{until (dealloc } t\text{ id }= e_3) \leadsto \sigma''}
    \text{\texttt{Loop1Main}}
\end{equation}

\begin{equation} \label{eq:loop1Rec}
    \frac{\substack{\sigma \vdash_{expr} e_3 \leadsto v_1 \\
            v_1 == false} ~~
        \sigma \vdash_{stmt} s \leadsto \sigma' ~~
        \sigma' \vdash_{AssVar} id \assigneq e_2 \leadsto \sigma'' ~~
        \substack{\sigma \vdash_{expr} e_1 \leadsto v_2 \\
            v_2 == false} ~~
        \sigma'' \vdash_{Loop1} (e_1, s, e_2, e_3) \leadsto \sigma'''}
    {\sigma \vdash_{Loop1} (e_1, s, e_2, e_3) \leadsto \sigma'''}
    \text{\texttt{Loop1Rec}}
\end{equation}

\begin{equation} \label{eq:loop1Base}
    \frac{\sigma \vdash_{expr} e_3 \leadsto v ~~
        v == true}
    {\sigma \vdash_{Loop1} (e_1, s, e_2, e_3) \leadsto \sigma}
    \text{\texttt{Loop1Base}}
\end{equation}

\begin{equation} \label{eq:loop2Main}
    \frac{\sigma \vdash_{local} \text{local } t \text{ id } = e_1 \leadsto \sigma' ~~
        \sigma' \vdash_{loop2} (e_1, s, e_2, e_3) \leadsto \sigma''}
    {\sigma \vdash_{stmt} \text{for local }t\text{ id }= e_1,\text{ id }\assigneq e_2 ~\{s\} \text{ until (dealloc } t\text{ id }= e_3) \leadsto \sigma''}
    \text{\texttt{Loop2Main}}
\end{equation}

\begin{equation} \label{eq:loop2Rec}
    \frac{\substack{\sigma \vdash_{expr} e_3 \leadsto v_1 \\
            v_1 == false} ~~
        \sigma \vdash_{AssVar} id \assigneq e_2 \leadsto \sigma' ~~
        \sigma' \vdash_{stmt} s \leadsto \sigma'' ~~
        \substack{\sigma \vdash_{expr} e_1 \leadsto v_2 \\
            v_2 == false} ~~
        \sigma'' \vdash_{Loop2} (s, e_2, e_3) \leadsto \sigma'''}
    {\sigma \vdash_{Loop2} (e_1, s, e_2, e_3) \leadsto \sigma'''}
    \text{\texttt{Loop2Rec}}
\end{equation}

\begin{equation} \label{eq:loop2Base}
    \frac{\sigma \vdash_{expr} e_3 \leadsto v ~~
        v == true}
    {\sigma \vdash_{Loop2} (e_1, s, e_2, e_3) \leadsto \sigma}
    \text{\texttt{Loop2Base}}
\end{equation}

\begin{equation} \label{eq:loop1MainInv}
    \frac{\sigma \vdash_{local} \text{local } t \text{ id } = e_1 \leadsto \sigma' ~~
        \sigma' \vdash_{expr} e_2 \leadsto true ~~
        \substack{\sigma' \vdash_{loop1} (e_1, e_2, s, e_3, e_4) \leadsto \sigma'' \\
            \sigma'' \vdash_{expr} e_2 \leadsto true}}
    {\sigma \vdash_{stmt} \text{for local }t\text{ id }= e_1, \text{ invariant }(e_2) ~\{s\}\text{ id }\assigneq e_3, \text{until (dealloc } t\text{ id }= e_4) \leadsto \sigma''}
    \text{\texttt{Loop1MainInv}}
\end{equation}

\begin{equation} \label{eq:loop1RecInv}
    \frac{\substack{\sigma \vdash_{expr} e_4 \leadsto v_1 \\
            v_1 == false \\
            \sigma \vdash_{expr} e_2 \leadsto true} ~~
        \sigma \vdash_{stmt} s \leadsto \sigma' ~~
        \sigma' \vdash_{AssVar} id \assigneq e_3 \leadsto \sigma'' ~~
        \substack{\sigma'' \vdash_{Loop1} (e_1, e_2, s, e_3, e_4) \leadsto \sigma''' \\
        \sigma''' \vdash_{expr} e_2 \leadsto true}}
    {\sigma \vdash_{Loop1} (e_1, e_2, s, e_3, e_4) \leadsto \sigma'''}
    \text{\texttt{Loop1RecInv}}
\end{equation}

\begin{equation} \label{eq:loop1BaseInv}
    \frac{\sigma \vdash_{expr} e_4 \leadsto v ~~
        v == true ~~
        \sigma \vdash_{expr} e_2 \leadsto true}
    {\sigma \vdash_{Loop1} (e_1, e_2, s, e_3, e_4) \leadsto \sigma}
    \text{\texttt{Loop1BaseInv}}
\end{equation}

\begin{equation} \label{eq:loop2MainInv}
    \frac{\sigma \vdash_{local} \text{local } t \text{ id } = e_1 \leadsto \sigma' ~~
        \sigma' \vdash_{expr} e_2 \leadsto true ~~
        \substack{\sigma' \vdash_{loop2} (e_1, e_2, s, e_3, e_4) \leadsto \sigma'' \\
            \sigma'' \vdash_{expr} e_2 \leadsto true}}
    {\sigma \vdash_{stmt} \text{for local }t\text{ id }= e_1, \text{ invariant }(e_2), \text{ id }\assigneq e_3 ~\{s\} \text{ until (dealloc } t\text{ id }= e_4) \leadsto \sigma''}
    \text{\texttt{Loop2MainInv}}
\end{equation}

\begin{equation} \label{eq:loop2RecInv}
    \frac{\substack{\sigma \vdash_{expr} e_4 \leadsto v_1 \\
            v_1 == false \\
            \sigma \vdash_{expr} e_2 \leadsto true} ~~
        \sigma' \vdash_{AssVar} id \assigneq e_3 \leadsto \sigma'' ~~
        \sigma \vdash_{stmt} s \leadsto \sigma' ~~
        \substack{\sigma'' \vdash_{Loop1} (e_1, e_2, s, e_3, e_4) \leadsto \sigma''' \\
            \sigma''' \vdash_{expr} e_2 \leadsto true}}
    {\sigma \vdash_{Loop2} (e_1, e_2, s, e_3, e_4) \leadsto \sigma'''}
    \text{\texttt{Loop2RecInv}}
\end{equation}

\begin{equation} \label{eq:loop2BaseInv}
    \frac{\sigma \vdash_{expr} e_4 \leadsto v ~~
        v == true ~~
        \sigma \vdash_{expr} e_2 \leadsto true}
    {\sigma \vdash_{Loop2} (e_1, e_2, s, e_3, e_4) \leadsto \sigma}
    \text{\texttt{Loop2BaseInv}}
\end{equation}
\noindent
Semantics of an assert it simply to assert, that the value of $e$ evaluated in $\sigma$ must
be true.

A local statement creates a new local variable to the scope, and
the dealloc asserts the value of the variable, and removes it from scope.

There are four different kinds of main rules working on the for-loop statement. All of which
have similar semantics, but differ slightly.
\eqref{eq:loop1Main} defines the semantics of the simple
forward for-loop (loop variable moderation after loop body), both for when the loop ending
condition is false, and when it's true. The loop semantics are defined as, first initializing
the loop variable, then checking whether the loop end condition is true. If not, the loop body
is run together with it's loop variable moderation, and the loop start condition is ensured to
be false. The difference between the \emph{loop1} and the \emph{loop2} rules is, whether
the loop variable moderation is run before or after the body statement.

Rules \eqref{eq:loop1MainInv} to \eqref{eq:loop2BaseInv} defined the loop semantics, when an
invariant is given. The invariant is checked after initialization of the loop variable, at
the start of each loop iteration, and after the loop finishes.

\subsection{Reversibility \rr} \label{subsec:reversibility}
Because the semantics of \lan is similar to that of \texttt{Janus}, as defined in \cite{janus},
this report will focus on proving reversibility of the divergent elements.
\\
\\
First off the statement must be proven to be forward and backward deterministic. If they are,
definition \ref{def:def:localReversibility} holds, and the statement is locally reversible.
For this Theorem \ref{theorem:determinism} must be proven (\cite{janus}):
\begin{theorem}[Forward \& backward determinism] \label{theorem:determinism}
    \begin{align*}
        \forall \sigma&, \sigma', \sigma''\in Stores[\lan]. \\
        &\sigma \vdash_{stmt} s \leadsto \sigma' \land \sigma \vdash s \leadsto \sigma''
            \implies \sigma = \sigma'' \\
        \forall \sigma&, \sigma', \sigma''\in Stores[\lan]. \\
        &\sigma' \vdash_{stmt} s \leadsto \sigma \land \sigma'' \vdash_{stmt} s \leadsto \sigma
            \implies \sigma' = \sigma''
    \end{align*}
\end{theorem}
\noindent
This theorem states that all statements in \lan are bijective, as given a state it only maps to
another unique state, and that given a statement mapping to one state, it must come from a
unique state; also all store states has a mapping statement between them.
Hence there is a one-to-one correspondence, and all statements will therefore be
invertible.
\\
\\
\textbf{Asserts:}
As assert statements in \lan does not alter the store in which they operate, both
forward and backwards determinism is trivially true $_\square$.
\\
\\
\textbf{Local variables:}
Looking at the semantic rule \eqref{eq:local} it is imminent, that for any program state,
the local declaration will always map to the state wherein any given $id$ maps to its given value
$v$. In other words the mapping created by this statement, does not depend on the starting state;
it will always have the same outcome; hence given any starting store, the local declaration can
only map to one other store state.

For backward determinism, we have that the local statement, must create the mapping to store
$\sigma[id \mapsto v]$, for some arbitrary $id$ and $v$. If we then remove the new mapping
$id \mapsto v$ from $\sigma$, we must get the original stores. But as this gives
$\sigma[id \mapsto v] \backslash \{id \mapsto v\} = \sigma$. It must be true, that no matter what
origin store, if they map to identical stores, they must themselves be equal $_\square$.
\\
\\
\textbf{Deallocation of variables:}
This prove is identical to the one for local variables. It simply removes a mapping instead of
adding one. Hence they must be forward deterministic, as given the same store $\sigma$, the 
statement simply removes a mapping. For backward determinism, adding the removed mapping from
the store, can only map to one store $_\square$.
\\
\\
\textbf{For loops:}
Any given \lan for-loop can be transformed into a sequence of \lan variable declaration and
deallocation, \texttt{Janus} from-loops, and \lan asserts by the below formula:

\begin{table}[H]
    \centering
    \begin{tabular}{l}
        \texttt{for local <type> <id> = <expr1> [, invariant (<expr2>)] \{} \\
        \texttt{ <stmts>} \\
        \texttt{\} <id> $\oplus$= <expr3>; until (dealloc <type> <id> == <expr4>)} \\ \\
        $~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\Downarrow$ \\ \\
        \texttt{local <type> <id> = <expr1>} \\
        \texttt{[assert(<expr2>)]} \\
        \texttt{from <expr1> loop} \\
        \texttt{  [assert(<expr2>)]} \\
        \texttt{  <stmts>} \\
        \texttt{  <id> $\oplus$= <expr3>} \\
        \texttt{until <expr4>} \\
        \texttt{[assert(<expr2)]}
    \end{tabular}
    \caption{\texttt{for}-loop transform into provable sections.}
    \label{table:for-loop-transform}
\end{table}
\noindent
Backwards directional for-loops can be likewise transformed, simply by putting the
moderation above the body statements, instead of after.

Hence by the above proves, and the one for \texttt{Janus} from-loops in \cite{janus}, \lan
for-loops must be both forward and backward deterministic $_\square$.