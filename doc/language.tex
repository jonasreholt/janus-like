% Use Roberts article to argue reversability and that local inversion is enough
% Also prove bijection (reversibility) of for-loops
\section{Janus-like Language Definition} \label{sec:language-def}
This project alters and extents the syntax for \texttt{Janus} to make it better match modern
programming languages. This "new" language will be an imperative reversible language like
\texttt{Janus}, and henceforth will be noted as \texttt{JAPA}
(short for Janus alike programming alternative) in this report.
But before altering the syntax and functionality of \texttt{Janus}, a more formal characterizations
of reversibility must be made.
Reversible computation refers to the use of logically reversible transformations \cite{ARTICLE:2},
and require two things: Local reversibility and global reversibility.

\begin{myDefinition}{Local reversibility}{def:localReversibility}
For a local process to be reversible information from step to step must be preserved, meaning no
information is destroyed \cite{ARTICLE:1}.
\end{myDefinition}

\begin{myDefinition}{Global reversibility}{def:globalReversibility}
A global process can only be reversible if the mapping from a start state to a final state is
bijective \cite{ARTICLE:1}. 
\end{myDefinition}
\noindent
This means that every construct of \texttt{JAPA} must preserve information over time, so the program
knows where to start of when running in either direction, and that there must be a "one-to-one"
transformation from every state. e.g. consider the assignment operator \texttt{var = 10}. This
statement has no way of undoing itself, as we do not know what \texttt{var} was before this
assignment, meaning it goes against definition \ref{def:def:localReversibility}. It also removes
the bijective property of the program, as all previous states of \texttt{var} leads to the same
final state where \texttt{var == 10}.
\\
\\
The definition for logical reversibility stated above does allow for all programs to be reversible,
as one could simply save a copy of the initial state and final state, as this would make
the program bijective, as the final program becomes a tuple $(state_{initial}, state_{final})$,
making the program transformation $\{state_{initial}\} \to \{state_{initial}, state_{final}\}$.
These program will however not live up to Landauer's Principle, if every individual step is not
reversible. It is therefore imminent that all construct of \texttt{LR} are reversible in them self.

\subsection{Data Types}
% TODO: Add bool type here
So far \texttt{JAPA} only support the same data types as \texttt{Janus}, which is
integers and arrays of integers, where integers are 32 bit positive integers.
The constraint with extending the type system to
e.g. floats is, that the data type is imprecise, meaning no perfect inverse is ensured
to exist.
\\
\\
Together with arrays come a set of library functions, which at the moment contains:

\begin{itemize}
    \item \texttt{length(x)} gives the length of the array $x$.
\end{itemize}

\subsection{Declaration of Variables}
There are essentially two types of variables: Global and local. Because a global variable is
always in scope, it preserves the information at all time (assuming all operations done on it
are reversible). Hence global variable declaration can simply be done by:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{<id>} & $\underleftrightarrow{\text{Inverse of}}$ & no inverse \\
        \texttt{<id>[]}
    \end{tabular}
\end{table*}
\noindent
Local variables are mote tricky, as they will leave the scope, meaning we cannot know the value
of the variable when running the program backwards, if the variable have left scope. Hence there
needs to be some operation stating what the value of the variable is when it is last used, so
the program step of leaving the scope of a local variable also becomes reversible. This can be
done in the following way:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{<id>} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{delocal <id> == <expr}
    \end{tabular}
\end{table*}
\noindent
It is important to note, that declaring a local, does not open a scope, meaning when a variable
$y$ is shadowed by a local $x$, it is not brought into the light by deallocation of $x$.

\subsection{Modification Arithmetics}
To modify a variable there needs to be a inverse function of the operator, such that the
modification can be reversed. As the only datatype for \texttt{JAPA} is integers, the only operators
with an inverse (the function is bijective) is addition, subtraction, and exclusive or.
Multiplication and division cannot be used, as they are not each others inverse when operating on
natural numbers. Hence the operation becomes:

\begin{table*}[h]
    \centering
    \begin{tabular}{lcl}
        \texttt{<id> += <expr1>} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{<id> -= <expr1} \\
        \texttt{<id> \textasciicircum= <expr2>} & & \texttt{<id> \textasciicircum= <expr2>}
    \end{tabular}
\end{table*}
\noindent
Where \textasciicircum ~indicates exclusive or.

\subsection{Arithmetics}
Performing arithmetics on expressions of the language does not require, that the arithmetic function
is bijective, as it is only the state transformations that need be bijective, e.g. in
\texttt{a += 5 $\*$ 6}, the expression \texttt{5 $\*$ 6} is not the "altering" function, and
inverse of the whole statement would simply be subtracting \texttt{5 $\*$ 6} from \texttt{a}.
\\
\\
The only thing one needs to remember is, that a variable name cannot occur at both side if the
statement is to be reversible. Having this constraint ensures forward and backward determinism
[FIND CITATION].

\subsection{If Statements}
The \texttt{if}-statements are similar to those of \texttt{Janus}:

\begin{table*}[h!]
    \centering
    \begin{tabular}{lcl}
        \texttt{if (<expr1>) \{} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{if (<expr2>) \{} \\
        \texttt{ <stmts>} && \text{<stmts>$^{-1}$} \\
        \texttt{\} fi <expr2>} && \texttt{\} fi <expr1>} \\
        \texttt{else \{} && \texttt{else \{} \\
        \texttt{ <stmts>} && \text{ <stmts>$^{-1}$} \\
        \texttt{\}} && \texttt{\}}
    \end{tabular}
\end{table*}
\noindent
Where the \texttt{else} part can be omitted.

\subsection{Loops}
\texttt{JAPA} will support two different kind of loops: a \texttt{for}- and a \texttt{from}-loop.
The \texttt{from}-loop is identical to the one from \texttt{Janus}:
\begin{table*}[H]
    \centering
    \begin{tabular}{lcl}
        \texttt{from <expr1> loop \{} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{from <expr2> do \{ }\\
        \texttt{ <stmts>} && \texttt{ <stmts>$^{-1}$} \\
        \texttt{\} until (<expr2>)} && \texttt{\} until (<expr1>)} 
    \end{tabular}
\end{table*}
\noindent
The \texttt{for}-loop is closer to \texttt{C++} syntax:

\begin{table*}[!h]
    \centering
    \begin{tabular}{lcl}
        \texttt{for <id> = <expr1> \{} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{for <id> = <expr2>; <inc>$^{-1}$ \{ }\\
        \texttt{ <stmts>} && \texttt{ <stmts>$^{-1}$} \\
        \texttt{\} <incr>; until (<id> == <expr2>)} && \texttt{\} until (<id> == <expr1>)} 
    \end{tabular}
\end{table*}
\noindent
Where \texttt{inc} is a modification operation typically on <id>, $a^{-1}$ indicated that
$a$ is reversed, and having \texttt{<inc>} above the body executes it before the body and
if it is after the body, it is executed after.
\\
\\
Moving the \texttt{<inc>} operation when reversing the loop is a necessity to make sure that
\texttt{<id>} always have to correct value when going into an iteration. If the operation was not
moved, the loop would be unaligned with its reversion. E.g. if the loop iterated over a list,
it might stop when \texttt{<id>} is equal to the length of the list. If we reversed without moving
the \texttt{<inc>} operation, the first iteration of the loop would access the index of the list
length, which would be out of bounds.

\subsection{Procedures}
Procedures in \texttt{JAPA} does not have a return value; every outcome is exposed through side
effect, by letting arguments be pass by reference. Return values are omitted because it
complicates preserving reversibility, as the program needs a way to know where to enter and exit
the procedure. This can be done by labeling all exits and possible enter areas with a condition,
so it would require the programmer to know the exact state of the program at all possible exit areas.
I have stayed at keeping procedure free of return values, for simplicity.
\\
\\
In regard to arguments, they can either be a constant value or a previous declared variable. This
extinction needs to be taken, to ensure reversibility, as a procedure has no way of knowing, whether
a given argument is a constant or variable, unless stated in the procedure definition. If variable
was passed by value without being constant, it would be the same as creating a local variable at
the start of the procedure; and given that the procedure input can change for every call, keeping
track of the deallocation condition becomes complex, and I therefore force variables to be either
pass by reference or a constant. Hence defining a procedure can be done as:

\begin{lstlisting}
    procedure <id>(<args>) {
        <stmts>
    }
\end{lstlisting}
\noindent
Where \texttt{<args>} is a comma separated list of arguments written \texttt{<type> <id>} or
\texttt{<type> const <id>}, where \texttt{const} indicates that the given argument is passed by
value, and the value cannot be altered in the procedure.
\\
\\
The reversibility of a procedure is straightforward now that all underlying statements are
reversible. It is simply done by:

\begin{table*}[!h]
    \centering
    \begin{tabular}{lcl}
        \texttt{call <id>(<args>)} & $\underleftrightarrow{\text{Inverse of}}$ & \texttt{uncall <id>(<args>)}
    \end{tabular}
\end{table*}
\noindent
Where \texttt{uncall} simply reverse the underlying statements.

\subsection{Formal Definition of Syntax}
The language \texttt{JAPA} can be formally written in Bacus-Naur form as:

\begin{verbatim}
    <program> := <v-decls> <p-decls>
    <v-decls> := <v-decl> <v-decls> | ""
    <p-decls> := <p-decl> <p-decls> | ""

    <v-decl>  := <type> <id> | <type> <id> "[" <const> "]"
    <p-decl>  := "procedure" <id> "(" <f-args> ")" "{" <stmts> "}"

    <f-args>  := <f-args'> | ""
    <f-args'> := <type> <id> "," <f-args'> | <type> <id> "[" "]" "," <f-args'>
              | <type> <id> | <type> <id> "[" "]"
    <a-args>  := <a-args'> | ""
    <a-args'> := <id> "," <a-args'> | <constant> "," <a-args'> | <id> "[" <expr> "]" "," <a-args'>
              | <id> | <id> "[" <expr> "]" | <constant> 
    
    <type>    := "int" | "bool"

    <stmts>   := <stmt> <stmts> | ""
    <stmt>    := "local" <type> <id> "=" <expr>
              | "dealloc" <type> <id> "=" <expr>
              | <id> <mod-op> "=" <expr>
              | <id> "[" <expr> "]" <mod-op> "=" <expr>
              | <id> "<=>" <id>
              | "if" "(" <expr> ")" "{" <stmts> "}" "fi" "(" <expr> ")" "else" "{" <stmts> "}"
              | "if" "(" <expr> ")" "{" <stmts> "}" "fi"
              | "for" <id> "=" <expr> "{" <stmts> "}"
                <id> <mod-op> "=" <expr> "," "untill" "(" <id> "=" <expr> ")"
              | "for" <id> "=" <expr> "," <id> <mod-op> "=" <expr> "{" <stmts> "}"
                "untill" "(" <id> "=" <expr> ")"
              | "call" <id> "(" <a-args> ")"
              | "uncall" <id> "(" <a-args> ")"

    <expr>    := <constant> | <id> | <id> "[" <expr> "]" | <expr> <bin-op> <expr>
              | "length" "(" <id> ")"

    <bin-op>  := "+" | "-" | "^" | "*" | "/" | "%" | "&" | "&&" | "|" | "||" | ">"
              | ">=" | "<" | "<=" | "!=" | "=="
    
    <mod-op>  := "+" | "-" | "^"
\end{verbatim}


% FULL GRAMMAR
% \begin{verbatim}
%     <program> := <v-decls> <p-decls>
%     <v-decls> := <v-decl> <v-decls> | ""
%     <p-decls> := <p-decl> <p-decls> | ""

%     <v-decl>  := <type> <id> | <type> <id> "[" <const> "]"
%     <p-decl>  := "procedure" <id> "(" <f-args> ")" "{" <stmts> "}"

%     <f-args>  := <f-args'> | ""
%     <f-args'> := <type> <id> "," <f-args'> | <type> <id> "[" "]" "," <f-args'>
%               | <type> <id> | <type> <id> "[" "]"
%     <a-args>  := <a-args'> | ""
%     <a-args'> := <id> "," <a-args'> | <constant> "," <a-args'> | <id> "[" <expr> "]" "," <a-args'>
%               | <id> | <id> "[" <expr> "]" | <constant> 
    
%     <type>    := "int"

%     <stmts>   := <stmt> <stmts> | ""
%     <stmt>    := "local" <type> <id> "=" <expr>
%               | "dealloc" <type> <id> "=" <expr>
%               | <id> <mod-op> "=" <expr>
%               | <id> "[" <expr> "]" <mod-op> "=" <expr>
%               | <id> "<=>" <id>
%               | "if" "(" <expr> ")" "{" <stmts> "}" "fi" "(" <expr> ")" "else" "{" <stmts> "}"
%               | "if" "(" <expr> ")" "{" <stmts> "}" "fi"
%               | "from" "(" <expr> ")" "loop" "{" <stmts> "}" "untill" "(" <expr> ")"
%               | "from" "(" <expr> ")" "do" "{" <stmts> "}" "untill" "(" <expr> ")"
%               | "for" <id> "=" <expr> "{" <stmts> "}" <id> <mod-op> "=" <expr> "," "untill" "(" <expr> ")"
%               | "for" <id> "=" <expr> "," <id> <mod-op> "=" <expr> "{" <stmts> "}" "untill" "(" <expr> ")"
%               | "call" <id> "(" <a-args> ")"
%               | "uncall" <id> "(" <a-args> ")"

%     <expr>    := <constant> | <id> | <id> "[" <expr> "]" | <expr> <bin-op> <expr>

%     <bin-op>  := "+" | "-" | "^" | "*" | "/" | "%" | "&" | "&&" | "|" | "||" | ">"
%               | ">=" | "<" | "<=" | "!=" | "=="
    
%     <mod-op>  := "+" | "-" | "^"
% \end{verbatim}
